{"version":3,"file":"angularfire2.js","sourceRoot":"","sources":["../../src/core/angularfire2.ts"],"names":[],"mappings":"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","sourcesContent":["import { InjectionToken, NgZone } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, Subscription, SchedulerLike, SchedulerAction, queueScheduler, Operator, Subscriber, TeardownLogic, asyncScheduler } from 'rxjs';\nimport { subscribeOn, observeOn, tap, share } from 'rxjs/operators';\n\n// Put in database.ts when we drop database-depreciated\n// SEMVER drop RealtimeDatabaseURL in favor of DATABASE_URL in next major\nexport const RealtimeDatabaseURL = new InjectionToken<string>('angularfire2.realtimeDatabaseURL');\nexport const DATABASE_URL = RealtimeDatabaseURL;\n\nfunction noop() { }\n\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\nexport class ɵZoneScheduler implements SchedulerLike {\n  constructor(private zone: any, private delegate: any = queueScheduler) { }\n\n  now() {\n    return this.delegate.now();\n  }\n\n  schedule(work: (this: SchedulerAction<any>, state?: any) => void, delay?: number, state?: any): Subscription {\n    const targetZone = this.zone;\n    // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n    const workInZone = function (this: SchedulerAction<any>, state: any) {\n      targetZone.runGuarded(() => {\n        work.apply(this, [state]);\n      });\n    }\n\n    // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n    return this.delegate.schedule(workInZone, delay, state)\n  }\n}\n\nexport class ɵBlockUntilFirstOperator<T> implements Operator<T, T> {\n  private task: MacroTask | null = null;\n\n  constructor(private zone: any) { }\n\n  call(subscriber: Subscriber<T>, source: Observable<T>): TeardownLogic {\n    const unscheduleTask = this.unscheduleTask.bind(this);\n    this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n\n    return source.pipe(\n      tap(unscheduleTask, unscheduleTask, unscheduleTask)\n    ).subscribe(subscriber).add(unscheduleTask);\n  }\n\n  private unscheduleTask() {\n    if (this.task != null && this.task.state === 'scheduled') {\n      this.task.invoke();\n      this.task = null;\n    }\n  }\n}\n\nexport class ɵAngularFireSchedulers {\n  public readonly outsideAngular: ɵZoneScheduler;\n  public readonly insideAngular: ɵZoneScheduler;\n\n  constructor(public ngZone: NgZone) {\n    this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));\n    this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));\n  }\n}\n\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n */\nexport function ɵkeepUnstableUntilFirstFactory(\n  schedulers: ɵAngularFireSchedulers,\n  platformId: Object\n) {\n  return function keepUnstableUntilFirst<T>(obs$: Observable<T>): Observable<T> {\n    if (isPlatformServer(platformId)) {\n      obs$ = obs$.lift(\n        new ɵBlockUntilFirstOperator(schedulers.ngZone)\n      );\n    }\n\n    return obs$.pipe(\n      // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n      subscribeOn(schedulers.outsideAngular),\n      // Run operators inside the angular zone (e.g. side effects via tap())\n      observeOn(schedulers.insideAngular)\n      // This isn't working correctly #2309, #2314, #2312\n      // share()\n    );\n  }\n}\n\n// SEMVER: drop v6, here for compatibility\nexport const runOutsideAngular = (zone: NgZone) => <T>(obs$: Observable<T>): Observable<T> => {\n  return new Observable<T>(subscriber => {\n    return zone.runOutsideAngular(() => {\n      runInZone(zone)(obs$).subscribe(subscriber);\n    });\n  });\n}\n\n// SEMVER: drop v6, here for compatibility\nexport const runInZone = (zone: NgZone) => <T>(obs$: Observable<T>): Observable<T> => {\n  return new Observable<T>(subscriber => {\n    return obs$.subscribe(\n      value => zone.run(() => subscriber.next(value)),\n      error => zone.run(() => subscriber.error(error)),\n      ()    => zone.run(() => subscriber.complete()),\n    );\n  });\n}\n\n// SEMVER: drop v6, here for compatibility\nexport class FirebaseZoneScheduler {\n  constructor(public zone: NgZone, private platformId: Object) {}\n  schedule(...args: any[]): Subscription {\n    return <Subscription>this.zone.runGuarded(function() { return queueScheduler.schedule.apply(queueScheduler, args)});\n  }\n  keepUnstableUntilFirst<T>(obs$: Observable<T>) {\n    if (isPlatformServer(this.platformId)) {\n      return new Observable<T>(subscriber => {\n        const noop = () => {};\n        const task = Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop);\n        obs$.subscribe(\n          next => {\n            if (task.state === 'scheduled') { task.invoke() };\n            subscriber.next(next);\n          },\n          error => {\n            if (task.state === 'scheduled') { task.invoke() }\n            subscriber.error(error);\n          },\n          () => {\n            if (task.state === 'scheduled') { task.invoke() }\n            subscriber.complete();\n          }\n        );\n      });\n    } else {\n      return obs$;\n    }\n  }\n  runOutsideAngular<T>(obs$: Observable<T>): Observable<T> {\n    return new Observable<T>(subscriber => {\n      return this.zone.runOutsideAngular(() => {\n        return obs$.subscribe(\n          value => this.zone.run(() => subscriber.next(value)),\n          error => this.zone.run(() => subscriber.error(error)),\n          ()    => this.zone.run(() => subscriber.complete()),\n        );\n      });\n    });\n  }\n}\n\n//SEMVER: once we move to TypeScript 3.6, we can use these to build lazy interfaces\n/*\n  type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\n  type PromiseReturningFunctionPropertyNames<T> = { [K in FunctionPropertyNames<T>]: ReturnType<T[K]> extends Promise<any> ? K : never }[FunctionPropertyNames<T>];\n  type NonPromiseReturningFunctionPropertyNames<T> = { [K in FunctionPropertyNames<T>]: ReturnType<T[K]> extends Promise<any> ? never : K }[FunctionPropertyNames<T>];\n  type NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\n\n  export type PromiseProxy<T> = { [K in NonFunctionPropertyNames<T>]: Promise<T[K]> } &\n    { [K in NonPromiseReturningFunctionPropertyNames<T>]: (...args: Parameters<T[K]>) => Promise<ReturnType<T[K]>> } &\n    { [K in PromiseReturningFunctionPropertyNames<T>   ]: (...args: Parameters<T[K]>) => ReturnType<T[K]> };\n*/\n\n// DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\nconst noopFunctions = ['ngOnDestroy'];\n\n// INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\nexport const ɵlazySDKProxy = (klass: any, observable: Observable<any>, zone: NgZone) => {\n  return new Proxy(klass, {\n    get: (_, name:string) => zone.runOutsideAngular(() => {\n      if (klass[name]) { return klass[name] }\n      if (noopFunctions.includes(name)) { return () => {} }\n      let promise = observable.toPromise().then(mod => {\n        const ret = mod && mod[name];\n        // TODO move to proper type guards\n        if (typeof ret == 'function') {\n          return ret.bind(mod);\n        } else if (ret && ret.then) {\n          return ret.then((res:any) => zone.run(() => res));\n        } else {\n          return zone.run(() => ret);\n        }\n      });\n      // recurse the proxy\n      return new Proxy(() => undefined, {\n          get: (_, name) => promise[name],\n          // TODO handle callbacks as transparently as I can \n          apply: (self, _, args) => promise.then(it => it && it(...args))\n        }\n      )\n    })\n  })\n};"]}