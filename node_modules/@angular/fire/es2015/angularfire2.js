import { InjectionToken } from '@angular/core';
import { isPlatformServer } from '@angular/common';
import { Observable, queueScheduler, asyncScheduler } from 'rxjs';
import { subscribeOn, observeOn, tap } from 'rxjs/operators';
export const RealtimeDatabaseURL = new InjectionToken('angularfire2.realtimeDatabaseURL');
export const DATABASE_URL = RealtimeDatabaseURL;
function noop() { }
export class ɵZoneScheduler {
    constructor(zone, delegate = queueScheduler) {
        this.zone = zone;
        this.delegate = delegate;
    }
    now() {
        return this.delegate.now();
    }
    schedule(work, delay, state) {
        const targetZone = this.zone;
        const workInZone = function (state) {
            targetZone.runGuarded(() => {
                work.apply(this, [state]);
            });
        };
        return this.delegate.schedule(workInZone, delay, state);
    }
}
export class ɵBlockUntilFirstOperator {
    constructor(zone) {
        this.zone = zone;
        this.task = null;
    }
    call(subscriber, source) {
        const unscheduleTask = this.unscheduleTask.bind(this);
        this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));
        return source.pipe(tap(unscheduleTask, unscheduleTask, unscheduleTask)).subscribe(subscriber).add(unscheduleTask);
    }
    unscheduleTask() {
        if (this.task != null && this.task.state === 'scheduled') {
            this.task.invoke();
            this.task = null;
        }
    }
}
export class ɵAngularFireSchedulers {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));
        this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));
    }
}
export function ɵkeepUnstableUntilFirstFactory(schedulers, platformId) {
    return function keepUnstableUntilFirst(obs$) {
        if (isPlatformServer(platformId)) {
            obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));
        }
        return obs$.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));
    };
}
export const runOutsideAngular = (zone) => (obs$) => {
    return new Observable(subscriber => {
        return zone.runOutsideAngular(() => {
            runInZone(zone)(obs$).subscribe(subscriber);
        });
    });
};
export const runInZone = (zone) => (obs$) => {
    return new Observable(subscriber => {
        return obs$.subscribe(value => zone.run(() => subscriber.next(value)), error => zone.run(() => subscriber.error(error)), () => zone.run(() => subscriber.complete()));
    });
};
export class FirebaseZoneScheduler {
    constructor(zone, platformId) {
        this.zone = zone;
        this.platformId = platformId;
    }
    schedule(...args) {
        return this.zone.runGuarded(function () { return queueScheduler.schedule.apply(queueScheduler, args); });
    }
    keepUnstableUntilFirst(obs$) {
        if (isPlatformServer(this.platformId)) {
            return new Observable(subscriber => {
                const noop = () => { };
                const task = Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop);
                obs$.subscribe(next => {
                    if (task.state === 'scheduled') {
                        task.invoke();
                    }
                    ;
                    subscriber.next(next);
                }, error => {
                    if (task.state === 'scheduled') {
                        task.invoke();
                    }
                    subscriber.error(error);
                }, () => {
                    if (task.state === 'scheduled') {
                        task.invoke();
                    }
                    subscriber.complete();
                });
            });
        }
        else {
            return obs$;
        }
    }
    runOutsideAngular(obs$) {
        return new Observable(subscriber => {
            return this.zone.runOutsideAngular(() => {
                return obs$.subscribe(value => this.zone.run(() => subscriber.next(value)), error => this.zone.run(() => subscriber.error(error)), () => this.zone.run(() => subscriber.complete()));
            });
        });
    }
}
const noopFunctions = ['ngOnDestroy'];
export const ɵlazySDKProxy = (klass, observable, zone) => {
    return new Proxy(klass, {
        get: (_, name) => zone.runOutsideAngular(() => {
            if (klass[name]) {
                return klass[name];
            }
            if (noopFunctions.includes(name)) {
                return () => { };
            }
            let promise = observable.toPromise().then(mod => {
                const ret = mod && mod[name];
                if (typeof ret == 'function') {
                    return ret.bind(mod);
                }
                else if (ret && ret.then) {
                    return ret.then((res) => zone.run(() => res));
                }
                else {
                    return zone.run(() => ret);
                }
            });
            return new Proxy(() => undefined, {
                get: (_, name) => promise[name],
                apply: (self, _, args) => promise.then(it => it && it(...args))
            });
        })
    });
};
//# sourceMappingURL=angularfire2.js.map