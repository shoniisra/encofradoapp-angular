var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { Injectable, Inject, Optional, NgZone, InjectionToken } from '@angular/core';
import { Observable, concat, of, pipe } from 'rxjs';
import { map, switchMap, tap, shareReplay, distinctUntilChanged, filter, groupBy, mergeMap, scan, withLatestFrom, startWith, debounceTime, observeOn } from 'rxjs/operators';
import { ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';
;
export const SETTINGS = new InjectionToken('angularfire2.remoteConfig.settings');
export const DEFAULTS = new InjectionToken('angularfire2.remoteConfig.defaultConfig');
import { _firebaseAppFactory, ɵAngularFireSchedulers } from '@angular/fire';
;
export class Value {
    constructor(_source, _value) {
        this._source = _source;
        this._value = _value;
    }
    asBoolean() { return ['1', 'true', 't', 'y', 'yes', 'on'].indexOf(this._value.toLowerCase()) > -1; }
    asString() { return this._value; }
    asNumber() { return Number(this._value) || 0; }
    getSource() { return this._source; }
}
export class Parameter extends Value {
    constructor(key, fetchTimeMillis, source, value) {
        super(source, value);
        this.key = key;
        this.fetchTimeMillis = fetchTimeMillis;
    }
}
const filterTest = (fn) => filter(it => Array.isArray(it) ? it.some(fn) : fn(it));
const ɵ0 = filterTest;
export const filterRemote = () => filterTest(p => p.getSource() === 'remote');
export const filterFresh = (howRecentInMillis) => filterTest(p => p.fetchTimeMillis + howRecentInMillis >= new Date().getTime());
let AngularFireRemoteConfig = class AngularFireRemoteConfig {
    constructor(options, nameOrConfig, settings, defaultConfig, zone) {
        this.zone = zone;
        const schedulers = new ɵAngularFireSchedulers(zone);
        const remoteConfig$ = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => zone.runOutsideAngular(() => import('firebase/remote-config'))), map(() => _firebaseAppFactory(options, zone, nameOrConfig)), map(app => app.remoteConfig()), tap(rc => {
            if (settings) {
                rc.settings = settings;
            }
            if (defaultConfig) {
                rc.defaultConfig = defaultConfig;
            }
        }), startWith(undefined), shareReplay({ bufferSize: 1, refCount: false }));
        const loadedRemoteConfig$ = remoteConfig$.pipe(filter(rc => !!rc));
        let default$ = of(Object.keys(defaultConfig || {}).reduce((c, k) => (Object.assign({}, c, { [k]: new Value("default", defaultConfig[k].toString()) })), {}));
        const filterOutDefaults = map(all => Object.keys(all)
            .filter(key => all[key].getSource() != 'default')
            .reduce((acc, key) => (Object.assign({}, acc, { [key]: all[key] })), {}));
        const existing$ = loadedRemoteConfig$.pipe(switchMap(rc => rc.activate()
            .then(() => rc.ensureInitialized())
            .then(() => rc.getAll())), filterOutDefaults);
        const fresh$ = loadedRemoteConfig$.pipe(switchMap(rc => zone.runOutsideAngular(() => rc.fetchAndActivate()
            .then(() => rc.ensureInitialized())
            .then(() => rc.getAll()))), filterOutDefaults);
        this.parameters = concat(default$, existing$, fresh$).pipe(scanToParametersArray(remoteConfig$), shareReplay({ bufferSize: 1, refCount: true }));
        this.changes = this.parameters.pipe(switchMap(params => of(...params)), groupBy(param => param.key), mergeMap(group => group.pipe(distinctUntilChanged())));
        this.strings = proxyAll(this.parameters, 'strings');
        this.booleans = proxyAll(this.parameters, 'booleans');
        this.numbers = proxyAll(this.parameters, 'numbers');
        return ɵlazySDKProxy(this, loadedRemoteConfig$, zone);
    }
};
AngularFireRemoteConfig = __decorate([
    Injectable(),
    __param(0, Inject(FIREBASE_OPTIONS)),
    __param(1, Optional()), __param(1, Inject(FIREBASE_APP_NAME)),
    __param(2, Optional()), __param(2, Inject(SETTINGS)),
    __param(3, Optional()), __param(3, Inject(DEFAULTS)),
    __metadata("design:paramtypes", [Object, Object, Object, Object, NgZone])
], AngularFireRemoteConfig);
export { AngularFireRemoteConfig };
const scanToParametersArray = (remoteConfig) => pipe(withLatestFrom(remoteConfig), scan((existing, [all, rc]) => {
    const allKeys = [...existing.map(p => p.key), ...Object.keys(all)].filter((v, i, a) => a.indexOf(v) === i);
    return allKeys.map(key => {
        const updatedValue = all[key];
        return updatedValue ? new Parameter(key, rc ? rc.fetchTimeMillis : -1, updatedValue.getSource(), updatedValue.asString())
            : existing.find(p => p.key === key);
    });
}, []));
const ɵ1 = scanToParametersArray;
const AS_TO_FN = { 'strings': 'asString', 'numbers': 'asNumber', 'booleans': 'asBoolean' };
const STATIC_VALUES = { 'numbers': 0, 'booleans': false, 'strings': undefined };
export const budget = (interval) => (source) => new Observable(observer => {
    let timedOut = false;
    const timeout = setTimeout(() => {
        observer.complete();
        timedOut = true;
    }, interval);
    return source.subscribe({
        next(val) { if (!timedOut) {
            observer.next(val);
        } },
        error(err) { if (!timedOut) {
            clearTimeout(timeout);
            observer.error(err);
        } },
        complete() { if (!timedOut) {
            clearTimeout(timeout);
            observer.complete();
        } }
    });
});
const typedMethod = (it) => {
    switch (typeof it) {
        case 'string': return 'asString';
        case 'boolean': return 'asBoolean';
        case 'number': return 'asNumber';
        default: return 'asString';
    }
};
const ɵ2 = typedMethod;
export function scanToObject(to = 'strings') {
    return pipe(scan((c, p) => (Object.assign({}, c, { [p.key]: typeof to === 'object' ?
            p[typedMethod(to[p.key])]() :
            p[AS_TO_FN[to]]() })), typeof to === 'object' ?
        to :
        {}), debounceTime(1), budget(10), distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)));
}
;
export function mapToObject(to = 'strings') {
    return pipe(map((params) => params.reduce((c, p) => (Object.assign({}, c, { [p.key]: typeof to === 'object' ?
            p[typedMethod(to[p.key])]() :
            p[AS_TO_FN[to]]() })), typeof to === 'object' ?
        to :
        {})), distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)));
}
;
const proxyAll = (observable, as) => new Proxy(observable.pipe(mapToObject(as)), {
    get: (self, name) => self[name] || observable.pipe(map(all => all.find(p => p.key === name)), map(param => param ? param[AS_TO_FN[as]]() : STATIC_VALUES[as]), distinctUntilChanged())
});
const ɵ3 = proxyAll;
export { ɵ0, ɵ1, ɵ2, ɵ3 };
//# sourceMappingURL=remote-config.js.map