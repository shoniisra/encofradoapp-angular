import * as tslib_1 from "tslib";
import { Injectable, Optional } from '@angular/core';
import * as Showdown from 'showdown';
import { ShowdownConfig } from './showdown-config.provider';
/**
 * @internal
 */
let { hasOwnProperty } = {};
/**
 * ### Example
 *
 * Setup as standalone
 * ```typescript
 * import { NgModule } from '@angular/core';
 * import { ShowdownConverter } from 'ngx-showdown';
 *
 * @NgModule({
 *   providers: [ ShowdownConverter ];
 * })
 * export class AppModule {}
 * ```
 *
 * Use the converter instance.
 * ```typescript
 * import { Injectable } from '@angular/core';
 * import { ShowdownConverter } from 'ngx-showdown';
 *
 * @Injectable()
 * export class SomeService {
 *   constructor(showdownConverter: ShowdownConverter) {
 *     let markdown: string = "**Some**";
 *     let html: string = showdownConverter.makeHtml(markdown);
 *     console.log(`some:\nmarkdown: ${markdown)\nhtml: ${html}\n`);
 *   }
 * }
 * ```
 */
let ShowdownConverter = class ShowdownConverter extends Showdown.Converter {
    constructor(config) {
        super(config && { extensions: config.extensions });
        this.setFlavor((config && config.flavor) || 'vanilla');
        this.setOptions(config);
    }
    /**
     * Set options to the converter.
     *
     * @param options - A options object to set.
     */
    setOptions(options) {
        for (let key in options) {
            if (hasOwnProperty.call(options, key)) {
                this.setOption(key, options[key]);
            }
        }
    }
};
ShowdownConverter = tslib_1.__decorate([
    Injectable(),
    tslib_1.__param(0, Optional()),
    tslib_1.__metadata("design:paramtypes", [ShowdownConfig])
], ShowdownConverter);
export { ShowdownConverter };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hvd2Rvd24tY29udmVydGVyLnByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXNob3dkb3duLyIsInNvdXJjZXMiOlsic2hvd2Rvd24tY29udmVydGVyLnByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRCxPQUFPLEtBQUssUUFBUSxNQUFNLFVBQVUsQ0FBQztBQUNyQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFFNUQ7O0dBRUc7QUFDSCxJQUFJLEVBQUMsY0FBYyxFQUFDLEdBQUcsRUFBRSxDQUFDO0FBRTFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNEJHO0FBRUgsSUFBYSxpQkFBaUIsR0FBOUIsTUFBYSxpQkFBa0IsU0FBUSxRQUFRLENBQUMsU0FBUztJQUV2RCxZQUF3QixNQUF1QjtRQUM3QyxLQUFLLENBQUMsTUFBTSxJQUFJLEVBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxVQUFVLEVBQUMsQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxVQUFVLENBQUMsT0FBaUM7UUFDakQsS0FBSyxJQUFJLEdBQUcsSUFBSSxPQUFPLEVBQUU7WUFDdkIsSUFBSSxjQUFjLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsRUFBRTtnQkFDckMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDbkM7U0FDRjtJQUNILENBQUM7Q0FFRixDQUFBO0FBckJZLGlCQUFpQjtJQUQ3QixVQUFVLEVBQUU7SUFHRSxtQkFBQSxRQUFRLEVBQUUsQ0FBQTs2Q0FBVSxjQUFjO0dBRnBDLGlCQUFpQixDQXFCN0I7U0FyQlksaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIFNob3dkb3duIGZyb20gJ3Nob3dkb3duJztcbmltcG9ydCB7IFNob3dkb3duQ29uZmlnIH0gZnJvbSAnLi9zaG93ZG93bi1jb25maWcucHJvdmlkZXInO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5sZXQge2hhc093blByb3BlcnR5fSA9IHt9O1xuXG4vKipcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogU2V0dXAgYXMgc3RhbmRhbG9uZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IFNob3dkb3duQ29udmVydGVyIH0gZnJvbSAnbmd4LXNob3dkb3duJztcbiAqXG4gKiBATmdNb2R1bGUoe1xuICogICBwcm92aWRlcnM6IFsgU2hvd2Rvd25Db252ZXJ0ZXIgXTtcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKiBgYGBcbiAqXG4gKiBVc2UgdGhlIGNvbnZlcnRlciBpbnN0YW5jZS5cbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IFNob3dkb3duQ29udmVydGVyIH0gZnJvbSAnbmd4LXNob3dkb3duJztcbiAqXG4gKiBASW5qZWN0YWJsZSgpXG4gKiBleHBvcnQgY2xhc3MgU29tZVNlcnZpY2Uge1xuICogICBjb25zdHJ1Y3RvcihzaG93ZG93bkNvbnZlcnRlcjogU2hvd2Rvd25Db252ZXJ0ZXIpIHtcbiAqICAgICBsZXQgbWFya2Rvd246IHN0cmluZyA9IFwiKipTb21lKipcIjtcbiAqICAgICBsZXQgaHRtbDogc3RyaW5nID0gc2hvd2Rvd25Db252ZXJ0ZXIubWFrZUh0bWwobWFya2Rvd24pO1xuICogICAgIGNvbnNvbGUubG9nKGBzb21lOlxcbm1hcmtkb3duOiAke21hcmtkb3duKVxcbmh0bWw6ICR7aHRtbH1cXG5gKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTaG93ZG93bkNvbnZlcnRlciBleHRlbmRzIFNob3dkb3duLkNvbnZlcnRlciB7XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgY29uZmlnPzogU2hvd2Rvd25Db25maWcpIHtcbiAgICBzdXBlcihjb25maWcgJiYge2V4dGVuc2lvbnM6IGNvbmZpZy5leHRlbnNpb25zfSk7XG4gICAgdGhpcy5zZXRGbGF2b3IoKGNvbmZpZyAmJiBjb25maWcuZmxhdm9yKSB8fCAndmFuaWxsYScpO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhjb25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBvcHRpb25zIHRvIHRoZSBjb252ZXJ0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQSBvcHRpb25zIG9iamVjdCB0byBzZXQuXG4gICAqL1xuICBwdWJsaWMgc2V0T3B0aW9ucyhvcHRpb25zOiBTaG93ZG93bi5TaG93ZG93bk9wdGlvbnMpOiB2b2lkIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywga2V5KSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihrZXksIG9wdGlvbnNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKiBAZGVwcmVjYXRlZCBmcm9tIHY1LCB1c2Uge0BsaW5rIFNob3dkb3duLkNvbnZlcnRlck9wdGlvbnN9IGluc3RlYWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbnZlcnRlck9wdGlvbnMgZXh0ZW5kcyBTaG93ZG93bi5Db252ZXJ0ZXJPcHRpb25zIHtcbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKiBAZGVwcmVjYXRlZCBmcm9tIHY1LCB1c2Uge0BsaW5rIFNob3dkb3duLlNob3dkb3duT3B0aW9uc30gaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJQ29udmVydGVyT3B0aW9uc0NoYW5nZWFibGUgZXh0ZW5kcyBTaG93ZG93bi5TaG93ZG93bk9wdGlvbnMge1xufVxuIl19