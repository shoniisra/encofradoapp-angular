import * as tslib_1 from "tslib";
import { Injectable, Optional } from '@angular/core';
import * as Showdown from 'showdown';
import { ShowdownConfig } from './showdown-config.provider';
/**
 * @internal
 */
var hasOwnProperty = {}.hasOwnProperty;
/**
 * ### Example
 *
 * Setup as standalone
 * ```typescript
 * import { NgModule } from '@angular/core';
 * import { ShowdownConverter } from 'ngx-showdown';
 *
 * @NgModule({
 *   providers: [ ShowdownConverter ];
 * })
 * export class AppModule {}
 * ```
 *
 * Use the converter instance.
 * ```typescript
 * import { Injectable } from '@angular/core';
 * import { ShowdownConverter } from 'ngx-showdown';
 *
 * @Injectable()
 * export class SomeService {
 *   constructor(showdownConverter: ShowdownConverter) {
 *     let markdown: string = "**Some**";
 *     let html: string = showdownConverter.makeHtml(markdown);
 *     console.log(`some:\nmarkdown: ${markdown)\nhtml: ${html}\n`);
 *   }
 * }
 * ```
 */
var ShowdownConverter = /** @class */ (function (_super) {
    tslib_1.__extends(ShowdownConverter, _super);
    function ShowdownConverter(config) {
        var _this = _super.call(this, config && { extensions: config.extensions }) || this;
        _this.setFlavor((config && config.flavor) || 'vanilla');
        _this.setOptions(config);
        return _this;
    }
    /**
     * Set options to the converter.
     *
     * @param options - A options object to set.
     */
    ShowdownConverter.prototype.setOptions = function (options) {
        for (var key in options) {
            if (hasOwnProperty.call(options, key)) {
                this.setOption(key, options[key]);
            }
        }
    };
    ShowdownConverter = tslib_1.__decorate([
        Injectable(),
        tslib_1.__param(0, Optional()),
        tslib_1.__metadata("design:paramtypes", [ShowdownConfig])
    ], ShowdownConverter);
    return ShowdownConverter;
}(Showdown.Converter));
export { ShowdownConverter };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hvd2Rvd24tY29udmVydGVyLnByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXNob3dkb3duLyIsInNvdXJjZXMiOlsic2hvd2Rvd24tY29udmVydGVyLnByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRCxPQUFPLEtBQUssUUFBUSxNQUFNLFVBQVUsQ0FBQztBQUNyQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFFNUQ7O0dBRUc7QUFDRSxJQUFBLGtDQUFjLENBQU87QUFFMUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0Qkc7QUFFSDtJQUF1Qyw2Q0FBa0I7SUFFdkQsMkJBQXdCLE1BQXVCO1FBQS9DLFlBQ0Usa0JBQU0sTUFBTSxJQUFJLEVBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxVQUFVLEVBQUMsQ0FBQyxTQUdqRDtRQUZDLEtBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZELEtBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7O0lBQzFCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksc0NBQVUsR0FBakIsVUFBa0IsT0FBaUM7UUFDakQsS0FBSyxJQUFJLEdBQUcsSUFBSSxPQUFPLEVBQUU7WUFDdkIsSUFBSSxjQUFjLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsRUFBRTtnQkFDckMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDbkM7U0FDRjtJQUNILENBQUM7SUFuQlUsaUJBQWlCO1FBRDdCLFVBQVUsRUFBRTtRQUdFLG1CQUFBLFFBQVEsRUFBRSxDQUFBO2lEQUFVLGNBQWM7T0FGcEMsaUJBQWlCLENBcUI3QjtJQUFELHdCQUFDO0NBQUEsQUFyQkQsQ0FBdUMsUUFBUSxDQUFDLFNBQVMsR0FxQnhEO1NBckJZLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBTaG93ZG93biBmcm9tICdzaG93ZG93bic7XG5pbXBvcnQgeyBTaG93ZG93bkNvbmZpZyB9IGZyb20gJy4vc2hvd2Rvd24tY29uZmlnLnByb3ZpZGVyJztcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IHtoYXNPd25Qcm9wZXJ0eX0gPSB7fTtcblxuLyoqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIFNldHVwIGFzIHN0YW5kYWxvbmVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQgeyBTaG93ZG93bkNvbnZlcnRlciB9IGZyb20gJ25neC1zaG93ZG93bic7XG4gKlxuICogQE5nTW9kdWxlKHtcbiAqICAgcHJvdmlkZXJzOiBbIFNob3dkb3duQ29udmVydGVyIF07XG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICogYGBgXG4gKlxuICogVXNlIHRoZSBjb252ZXJ0ZXIgaW5zdGFuY2UuXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQgeyBTaG93ZG93bkNvbnZlcnRlciB9IGZyb20gJ25neC1zaG93ZG93bic7XG4gKlxuICogQEluamVjdGFibGUoKVxuICogZXhwb3J0IGNsYXNzIFNvbWVTZXJ2aWNlIHtcbiAqICAgY29uc3RydWN0b3Ioc2hvd2Rvd25Db252ZXJ0ZXI6IFNob3dkb3duQ29udmVydGVyKSB7XG4gKiAgICAgbGV0IG1hcmtkb3duOiBzdHJpbmcgPSBcIioqU29tZSoqXCI7XG4gKiAgICAgbGV0IGh0bWw6IHN0cmluZyA9IHNob3dkb3duQ29udmVydGVyLm1ha2VIdG1sKG1hcmtkb3duKTtcbiAqICAgICBjb25zb2xlLmxvZyhgc29tZTpcXG5tYXJrZG93bjogJHttYXJrZG93bilcXG5odG1sOiAke2h0bWx9XFxuYCk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2hvd2Rvd25Db252ZXJ0ZXIgZXh0ZW5kcyBTaG93ZG93bi5Db252ZXJ0ZXIge1xuXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIGNvbmZpZz86IFNob3dkb3duQ29uZmlnKSB7XG4gICAgc3VwZXIoY29uZmlnICYmIHtleHRlbnNpb25zOiBjb25maWcuZXh0ZW5zaW9uc30pO1xuICAgIHRoaXMuc2V0Rmxhdm9yKChjb25maWcgJiYgY29uZmlnLmZsYXZvcikgfHwgJ3ZhbmlsbGEnKTtcbiAgICB0aGlzLnNldE9wdGlvbnMoY29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgb3B0aW9ucyB0byB0aGUgY29udmVydGVyLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEEgb3B0aW9ucyBvYmplY3QgdG8gc2V0LlxuICAgKi9cbiAgcHVibGljIHNldE9wdGlvbnMob3B0aW9uczogU2hvd2Rvd24uU2hvd2Rvd25PcHRpb25zKTogdm9pZCB7XG4gICAgZm9yIChsZXQga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oa2V5LCBvcHRpb25zW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbi8qKlxuICogQGlnbm9yZVxuICogQGRlcHJlY2F0ZWQgZnJvbSB2NSwgdXNlIHtAbGluayBTaG93ZG93bi5Db252ZXJ0ZXJPcHRpb25zfSBpbnN0ZWFkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDb252ZXJ0ZXJPcHRpb25zIGV4dGVuZHMgU2hvd2Rvd24uQ29udmVydGVyT3B0aW9ucyB7XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICogQGRlcHJlY2F0ZWQgZnJvbSB2NSwgdXNlIHtAbGluayBTaG93ZG93bi5TaG93ZG93bk9wdGlvbnN9IGluc3RlYWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbnZlcnRlck9wdGlvbnNDaGFuZ2VhYmxlIGV4dGVuZHMgU2hvd2Rvd24uU2hvd2Rvd25PcHRpb25zIHtcbn1cbiJdfQ==