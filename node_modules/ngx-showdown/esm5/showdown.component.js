import * as tslib_1 from "tslib";
var e_1, _a;
import { Component, ElementRef, Input, Optional, SecurityContext } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import * as Showdown from 'showdown';
import { ShowdownConfig } from './showdown-config.provider';
import { ShowdownConverter } from './showdown-converter.provider';
/**
 * @internal
 */
var MAP_OPTION = {
    '': true,
    true: true,
    false: false
};
/**
 * @internal
 */
var _toOption = function (value) { return MAP_OPTION.hasOwnProperty(value) ? MAP_OPTION[value] : value; };
var ɵ0 = _toOption;
/**
 * The options keys for the dynamic properties set
 * @internal
 */
var OPTIONS_PROPERTIES_KEYS = Object.keys(Showdown.getDefaultOptions());
/**
 * A angular component for render `Markdown` to `HTML`.
 *
 * ### Example
 *
 * Setup as standalone
 * ```typescript
 * import { NgModule } from '@angular/core';
 * import { ShowdownComponent } from 'ngx-showdown';
 *
 * @NgModule({
 *   declarations: [ ShowdownComponent ];
 * })
 * export class AppModule {}
 * ```
 *
 * Bind markdown value and options object
 * ```typescript
 * import { Component } from '@angular/core';
 * import * as Showdown from 'showdown';
 *
 * @Component({
 *   selector: 'some',
 *   template: '<showdown [value]="text" [options]="options"></showdown>'
 * })
 * export class SomeComponent {
 *   text: string = `
 *     # Some header
 *     ---
 *     **Some bold**
 *   `;
 *   options: Showdown.ShowdownOptions = { smartIndentationFix: true };
 *   // ...
 * }
 * ```
 * Bind single option (it have properties for all showdown options).
 * ```html
 * <showdown emoji="true"  noHeaderId># Some text :+1:</showdown>
 * ```
 *
 * Set static markdown value.
 * ```html
 * <showdown value="___Some static value___" underline></showdown>
 * ```
 *
 * Use as directive on anther element.
 * ```html
 * <div showdown="# Div Element" headerLevelStart="2"></div>
 * ```
 *
 * Static markdown value in the element content.
 * ```html
 * <div>
 *    <showdown smartIndentationFix>
 *       # List:
 *       * a
 *            * A
 *       * b
 *    </showdown>
 * </div>
 * ```
 *
 * Set template reference variable.
 * ```html
 * <showdown #sd></showdown>
 * ```
 * Or
 * ```html
 * <div showdown #sd="showdown"></div>
 * ```
 */
var ShowdownComponent = /** @class */ (function (_super) {
    tslib_1.__extends(ShowdownComponent, _super);
    function ShowdownComponent(_elementRef, _domSanitizer, config) {
        var _this = _super.call(this, config) || this;
        _this._elementRef = _elementRef;
        _this._domSanitizer = _domSanitizer;
        return _this;
    }
    Object.defineProperty(ShowdownComponent.prototype, "showdown", {
        /**
         * Input alias to `value`.
         *
         * __Example :__
         *
         * ```html
         * <div [showdown]="# Some Header"></div>
         * ```
         *
         * Equivalent to
         * ```html
         * <showdown [value]="# Some Header"></showdown>
         * ```
         */
        set: function (value) {
            this.value = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShowdownComponent.prototype, "options", {
        /**
         * The showdown options of the converter.
         *
         * __Example :__
         *
         * Bind options
         * ```typescript
         * import { Component } from '@angular/core';
         * import * as Showdown from 'showdown';
         *
         * @Component({
         *   selector: `some`,
         *   template: `<showdown [options]="options"># Some Header<showdown>`
         * })
         * export class SomeComponent {
         *   options: Showdown.ShowdownOptions = {headerLevelStart: 3};
         *   // ...
         * }
         * ```
         * Or
         * ```html
         * <showdown [options]="{smartIndentationFix: true}"> # Indentation Fix<showdown>
         * ```
         */
        get: function () {
            return this.getOptions();
        },
        set: function (options) {
            this.setOptions(options);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShowdownComponent.prototype, "sanitize", {
        /**
         * Enables html sanitize, it will sanitize the converter html output by [`DomSanitizer`](https://angular.io/api/platform-browser/DomSanitizer#sanitize).
         *
         * __Example :__
         *
         * ```typescript
         * import { Component } from '@angular/core';
         *
         * @Component({
         *   selector: 'some',
         *   styles: [`.box { width: 95%; padding: 5px; border: 1px solid black;}`],
         *   template: `
         *     <h3>Input</h3>
         *     <textarea class="box" [(ngModel)]="text"></textarea>
         *     <input type="checkbox" [(ngModel)]="sanitize"/> <b>Sanitize</b>
         *     <h3>Markdown</h3>
         *     <pre class="box"><code>{{ text }}</code></pre>
         *     <h3>Preview</h3>
         *     <div class="box">
         *       <showdown #sd [value]="text" [sanitize]="sanitize"></showdown>
         *     </div>
         *   `;
         * })
         * export class SomeComponent {
         *    text: string = `# A cool link
         * <a href="javascript:alert('Hello!')">click me</a>`;
         * }
         * ```
         */
        set: function (sanitize) {
            this._sanitize = _toOption(sanitize);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * A angular lifecycle method, Use on init to check if it `content` type and load the element `content` to `value`.
     * @internal
     */
    ShowdownComponent.prototype.ngOnInit = function () {
        if (this.value === undefined && this._elementRef.nativeElement.innerHTML.trim() !== '') {
            this.render(this._elementRef.nativeElement.innerHTML);
        }
    };
    /**
     * A angular lifecycle method, Use to call to render method after changes.
     * @internal
     */
    ShowdownComponent.prototype.ngOnChanges = function () {
        this.render();
    };
    /**
     * Convert the markdown value of {@link ShowdownComponent#value} to html and set the html result to the element content.
     *
     * __Example :__
     *
     * ```html
     * <textarea #textarea (change)="showdown.render(textarea.value)"/># Some Header</textarea>
     * <showdown #showdown></showdown>
     * ```
     * @param value - A markdown value to render (it will override the current value of `ShowdownComponent#value`)
     */
    ShowdownComponent.prototype.render = function (value) {
        if (typeof value === 'string') {
            this.value = value;
        }
        if (typeof this.value === 'string') {
            var result = this.makeHtml(this.value);
            if (this._sanitize) {
                result = this._domSanitizer.sanitize(SecurityContext.HTML, result);
            }
            this._elementRef.nativeElement.innerHTML = result;
        }
    };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], ShowdownComponent.prototype, "value", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], ShowdownComponent.prototype, "showdown", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], ShowdownComponent.prototype, "options", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], ShowdownComponent.prototype, "sanitize", null);
    ShowdownComponent = tslib_1.__decorate([
        Component({
            selector: 'showdown,[showdown]',
            template: '<ng-content></ng-content>',
            exportAs: 'showdown',
            inputs: OPTIONS_PROPERTIES_KEYS
        }),
        tslib_1.__param(1, Optional()), tslib_1.__param(2, Optional()),
        tslib_1.__metadata("design:paramtypes", [ElementRef, DomSanitizer, ShowdownConfig])
    ], ShowdownComponent);
    return ShowdownComponent;
}(ShowdownConverter));
export { ShowdownComponent };
var _loop_1 = function (key) {
    Object.defineProperty(ShowdownComponent.prototype, key, {
        set: function (value) {
            this.setOption(key, _toOption(value));
        },
        configurable: true
    });
};
try {
    // Define options properties setter for angular directive and direct access
    for (var OPTIONS_PROPERTIES_KEYS_1 = tslib_1.__values(OPTIONS_PROPERTIES_KEYS), OPTIONS_PROPERTIES_KEYS_1_1 = OPTIONS_PROPERTIES_KEYS_1.next(); !OPTIONS_PROPERTIES_KEYS_1_1.done; OPTIONS_PROPERTIES_KEYS_1_1 = OPTIONS_PROPERTIES_KEYS_1.next()) {
        var key = OPTIONS_PROPERTIES_KEYS_1_1.value;
        _loop_1(key);
    }
}
catch (e_1_1) { e_1 = { error: e_1_1 }; }
finally {
    try {
        if (OPTIONS_PROPERTIES_KEYS_1_1 && !OPTIONS_PROPERTIES_KEYS_1_1.done && (_a = OPTIONS_PROPERTIES_KEYS_1.return)) _a.call(OPTIONS_PROPERTIES_KEYS_1);
    }
    finally { if (e_1) throw e_1.error; }
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hvd2Rvd24uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXNob3dkb3duLyIsInNvdXJjZXMiOlsic2hvd2Rvd24uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFxQixRQUFRLEVBQUUsZUFBZSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNHLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUN6RCxPQUFPLEtBQUssUUFBUSxNQUFNLFVBQVUsQ0FBQztBQUNyQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDNUQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFbEU7O0dBRUc7QUFDSCxJQUFNLFVBQVUsR0FBRztJQUNqQixFQUFFLEVBQUUsSUFBSTtJQUNSLElBQUksRUFBRSxJQUFJO0lBQ1YsS0FBSyxFQUFFLEtBQUs7Q0FDYixDQUFDO0FBRUY7O0dBRUc7QUFDSCxJQUFJLFNBQVMsR0FBRyxVQUFDLEtBQVUsSUFBSyxPQUFBLFVBQVUsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUE1RCxDQUE0RCxDQUFDOztBQUU3Rjs7O0dBR0c7QUFDSCxJQUFNLHVCQUF1QixHQUFhLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGlCQUFpQixFQUFFLENBQUMsQ0FBQztBQU1wRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNFRztBQU9IO0lBQXVDLDZDQUFpQjtJQTJHdEQsMkJBQW9CLFdBQXVCLEVBQXNCLGFBQTRCLEVBQWMsTUFBdUI7UUFBbEksWUFDRSxrQkFBTSxNQUFNLENBQUMs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WUFBWSxFQUFFLElBQUk7S0FDbkIsQ0FBQyxDQUFDOzs7SUFQTCwyRUFBMkU7SUFDM0UsS0FBZ0IsSUFBQSw0QkFBQSxpQkFBQSx1QkFBdUIsQ0FBQSxnRUFBQTtRQUFsQyxJQUFJLEdBQUcsb0NBQUE7Z0JBQUgsR0FBRztLQU9YIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkluaXQsIE9wdGlvbmFsLCBTZWN1cml0eUNvbnRleHQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERvbVNhbml0aXplciB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0ICogYXMgU2hvd2Rvd24gZnJvbSAnc2hvd2Rvd24nO1xuaW1wb3J0IHsgU2hvd2Rvd25Db25maWcgfSBmcm9tICcuL3Nob3dkb3duLWNvbmZpZy5wcm92aWRlcic7XG5pbXBvcnQgeyBTaG93ZG93bkNvbnZlcnRlciB9IGZyb20gJy4vc2hvd2Rvd24tY29udmVydGVyLnByb3ZpZGVyJztcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTUFQX09QVElPTiA9IHtcbiAgJyc6IHRydWUsXG4gIHRydWU6IHRydWUsXG4gIGZhbHNlOiBmYWxzZVxufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IF90b09wdGlvbiA9ICh2YWx1ZTogYW55KSA9PiBNQVBfT1BUSU9OLmhhc093blByb3BlcnR5KHZhbHVlKSA/IE1BUF9PUFRJT05bdmFsdWVdIDogdmFsdWU7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMga2V5cyBmb3IgdGhlIGR5bmFtaWMgcHJvcGVydGllcyBzZXRcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBPUFRJT05TX1BST1BFUlRJRVNfS0VZUzogc3RyaW5nW10gPSBPYmplY3Qua2V5cyhTaG93ZG93bi5nZXREZWZhdWx0T3B0aW9ucygpKTtcblxuLy8gRm9yIHRoZSBvcHRpb25zIHNldHRlciBwcm9wZXJ0aWVzIHRoYXQgZHluYW1pYyBkZWZpbml0aW9uICh0aGUgY29kZSBhZnRlciB0aGUgY2xhc3MpXG5leHBvcnQgaW50ZXJmYWNlIFNob3dkb3duQ29tcG9uZW50IGV4dGVuZHMgU2hvd2Rvd24uU2hvd2Rvd25PcHRpb25zIHtcbn1cblxuLyoqXG4gKiBBIGFuZ3VsYXIgY29tcG9uZW50IGZvciByZW5kZXIgYE1hcmtkb3duYCB0byBgSFRNTGAuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBTZXR1cCBhcyBzdGFuZGFsb25lXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgU2hvd2Rvd25Db21wb25lbnQgfSBmcm9tICduZ3gtc2hvd2Rvd24nO1xuICpcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGRlY2xhcmF0aW9uczogWyBTaG93ZG93bkNvbXBvbmVudCBdO1xuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqIGBgYFxuICpcbiAqIEJpbmQgbWFya2Rvd24gdmFsdWUgYW5kIG9wdGlvbnMgb2JqZWN0XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCAqIGFzIFNob3dkb3duIGZyb20gJ3Nob3dkb3duJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdzb21lJyxcbiAqICAgdGVtcGxhdGU6ICc8c2hvd2Rvd24gW3ZhbHVlXT1cInRleHRcIiBbb3B0aW9uc109XCJvcHRpb25zXCI+PC9zaG93ZG93bj4nXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFNvbWVDb21wb25lbnQge1xuICogICB0ZXh0OiBzdHJpbmcgPSBgXG4gKiAgICAgIyBTb21lIGhlYWRlclxuICogICAgIC0tLVxuICogICAgICoqU29tZSBib2xkKipcbiAqICAgYDtcbiAqICAgb3B0aW9uczogU2hvd2Rvd24uU2hvd2Rvd25PcHRpb25zID0geyBzbWFydEluZGVudGF0aW9uRml4OiB0cnVlIH07XG4gKiAgIC8vIC4uLlxuICogfVxuICogYGBgXG4gKiBCaW5kIHNpbmdsZSBvcHRpb24gKGl0IGhhdmUgcHJvcGVydGllcyBmb3IgYWxsIHNob3dkb3duIG9wdGlvbnMpLlxuICogYGBgaHRtbFxuICogPHNob3dkb3duIGVtb2ppPVwidHJ1ZVwiICBub0hlYWRlcklkPiMgU29tZSB0ZXh0IDorMTo8L3Nob3dkb3duPlxuICogYGBgXG4gKlxuICogU2V0IHN0YXRpYyBtYXJrZG93biB2YWx1ZS5cbiAqIGBgYGh0bWxcbiAqIDxzaG93ZG93biB2YWx1ZT1cIl9fX1NvbWUgc3RhdGljIHZhbHVlX19fXCIgdW5kZXJsaW5lPjwvc2hvd2Rvd24+XG4gKiBgYGBcbiAqXG4gKiBVc2UgYXMgZGlyZWN0aXZlIG9uIGFudGhlciBlbGVtZW50LlxuICogYGBgaHRtbFxuICogPGRpdiBzaG93ZG93bj1cIiMgRGl2IEVsZW1lbnRcIiBoZWFkZXJMZXZlbFN0YXJ0PVwiMlwiPjwvZGl2PlxuICogYGBgXG4gKlxuICogU3RhdGljIG1hcmtkb3duIHZhbHVlIGluIHRoZSBlbGVtZW50IGNvbnRlbnQuXG4gKiBgYGBodG1sXG4gKiA8ZGl2PlxuICogICAgPHNob3dkb3duIHNtYXJ0SW5kZW50YXRpb25GaXg+XG4gKiAgICAgICAjIExpc3Q6XG4gKiAgICAgICAqIGFcbiAqICAgICAgICAgICAgKiBBXG4gKiAgICAgICAqIGJcbiAqICAgIDwvc2hvd2Rvd24+XG4gKiA8L2Rpdj5cbiAqIGBgYFxuICpcbiAqIFNldCB0ZW1wbGF0ZSByZWZlcmVuY2UgdmFyaWFibGUuXG4gKiBgYGBodG1sXG4gKiA8c2hvd2Rvd24gI3NkPjwvc2hvd2Rvd24+XG4gKiBgYGBcbiAqIE9yXG4gKiBgYGBodG1sXG4gKiA8ZGl2IHNob3dkb3duICNzZD1cInNob3dkb3duXCI+PC9kaXY+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnc2hvd2Rvd24sW3Nob3dkb3duXScsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIGV4cG9ydEFzOiAnc2hvd2Rvd24nLFxuICBpbnB1dHM6IE9QVElPTlNfUFJPUEVSVElFU19LRVlTXG59KVxuZXhwb3J0IGNsYXNzIFNob3dkb3duQ29tcG9uZW50IGV4dGVuZHMgU2hvd2Rvd25Db252ZXJ0ZXIgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgU2hvd2Rvd24uU2hvd2Rvd25PcHRpb25zIHtcblxuICAvKipcbiAgICogVGhlIGlucHV0IG1hcmtkb3duIHZhbHVlLlxuICAgKlxuICAgKiBfX0V4YW1wbGUgOl9fXG4gICAqXG4gICAqIFNldCBzb21lIHN0YXRpYyBtYXJrZG93biB2YWx1ZS5cbiAgICogYGBgaHRtbFxuICAgKiA8c2hvd2Rvd24gdmFsdWU9XCIqKlNvbWUgYm9sZCB2YWx1ZSoqXCI+PC9zaG93ZG93bj5cbiAgICogYGBgXG4gICAqXG4gICAqIEJpbmQgcHJvcGVydHkgd2l0aCBtYXJrZG93biB2YWx1ZS5cbiAgICogYGBgaHRtbFxuICAgKiA8dGV4dGFyZWEgWyhuZ01vZGVsKV09XCJ0ZXh0XCI+PC90ZXh0YXJlYT5cbiAgICogPHNob3dkb3duIFt2YWx1ZV09XCJ0ZXh0XCI+PC9zaG93ZG93bj5cbiAgICogYGBgXG4gICAqL1xuICBASW5wdXQoKSB2YWx1ZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJbnB1dCBhbGlhcyB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBfX0V4YW1wbGUgOl9fXG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGRpdiBbc2hvd2Rvd25dPVwiIyBTb21lIEhlYWRlclwiPjwvZGl2PlxuICAgKiBgYGBcbiAgICpcbiAgICogRXF1aXZhbGVudCB0b1xuICAgKiBgYGBodG1sXG4gICAqIDxzaG93ZG93biBbdmFsdWVdPVwiIyBTb21lIEhlYWRlclwiPjwvc2hvd2Rvd24+XG4gICAqIGBgYFxuICAgKi9cbiAgQElucHV0KCkgc2V0IHNob3dkb3duKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNob3dkb3duIG9wdGlvbnMgb2YgdGhlIGNvbnZlcnRlci5cbiAgICpcbiAgICogX19FeGFtcGxlIDpfX1xuICAgKlxuICAgKiBCaW5kIG9wdGlvbnNcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAgICogaW1wb3J0ICogYXMgU2hvd2Rvd24gZnJvbSAnc2hvd2Rvd24nO1xuICAgKlxuICAgKiBAQ29tcG9uZW50KHtcbiAgICogICBzZWxlY3RvcjogYHNvbWVgLFxuICAgKiAgIHRlbXBsYXRlOiBgPHNob3dkb3duIFtvcHRpb25zXT1cIm9wdGlvbnNcIj4jIFNvbWUgSGVhZGVyPHNob3dkb3duPmBcbiAgICogfSlcbiAgICogZXhwb3J0IGNsYXNzIFNvbWVDb21wb25lbnQge1xuICAgKiAgIG9wdGlvbnM6IFNob3dkb3duLlNob3dkb3duT3B0aW9ucyA9IHtoZWFkZXJMZXZlbFN0YXJ0OiAzfTtcbiAgICogICAvLyAuLi5cbiAgICogfVxuICAgKiBgYGBcbiAgICogT3JcbiAgICogYGBgaHRtbFxuICAgKiA8c2hvd2Rvd24gW29wdGlvbnNdPVwie3NtYXJ0SW5kZW50YXRpb25GaXg6IHRydWV9XCI+ICMgSW5kZW50YXRpb24gRml4PHNob3dkb3duPlxuICAgKiBgYGBcbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBvcHRpb25zKCk6IFNob3dkb3duLlNob3dkb3duT3B0aW9ucyB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucygpO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob3B0aW9uczogU2hvd2Rvd24uU2hvd2Rvd25PcHRpb25zKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2FuaXRpemU6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgaHRtbCBzYW5pdGl6ZSwgaXQgd2lsbCBzYW5pdGl6ZSB0aGUgY29udmVydGVyIGh0bWwgb3V0cHV0IGJ5IFtgRG9tU2FuaXRpemVyYF0oaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9wbGF0Zm9ybS1icm93c2VyL0RvbVNhbml0aXplciNzYW5pdGl6ZSkuXG4gICAqXG4gICAqIF9fRXhhbXBsZSA6X19cbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAgICpcbiAgICogQENvbXBvbmVudCh7XG4gICAqICAgc2VsZWN0b3I6ICdzb21lJyxcbiAgICogICBzdHlsZXM6IFtgLmJveCB7IHdpZHRoOiA5NSU7IHBhZGRpbmc6IDVweDsgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7fWBdLFxuICAgKiAgIHRlbXBsYXRlOiBgXG4gICAqICAgICA8aDM+SW5wdXQ8L2gzPlxuICAgKiAgICAgPHRleHRhcmVhIGNsYXNzPVwiYm94XCIgWyhuZ01vZGVsKV09XCJ0ZXh0XCI+PC90ZXh0YXJlYT5cbiAgICogICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBbKG5nTW9kZWwpXT1cInNhbml0aXplXCIvPiA8Yj5TYW5pdGl6ZTwvYj5cbiAgICogICAgIDxoMz5NYXJrZG93bjwvaDM+XG4gICAqICAgICA8cHJlIGNsYXNzPVwiYm94XCI+PGNvZGU+e3sgdGV4dCB9fTwvY29kZT48L3ByZT5cbiAgICogICAgIDxoMz5QcmV2aWV3PC9oMz5cbiAgICogICAgIDxkaXYgY2xhc3M9XCJib3hcIj5cbiAgICogICAgICAgPHNob3dkb3duICNzZCBbdmFsdWVdPVwidGV4dFwiIFtzYW5pdGl6ZV09XCJzYW5pdGl6ZVwiPjwvc2hvd2Rvd24+XG4gICAqICAgICA8L2Rpdj5cbiAgICogICBgO1xuICAgKiB9KVxuICAgKiBleHBvcnQgY2xhc3MgU29tZUNvbXBvbmVudCB7XG4gICAqICAgIHRleHQ6IHN0cmluZyA9IGAjIEEgY29vbCBsaW5rXG4gICAqIDxhIGhyZWY9XCJqYXZhc2NyaXB0OmFsZXJ0KCdIZWxsbyEnKVwiPmNsaWNrIG1lPC9hPmA7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgc2FuaXRpemUoc2FuaXRpemU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9zYW5pdGl6ZSA9IF90b09wdGlvbihzYW5pdGl6ZSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBAT3B0aW9uYWwoKSBwcml2YXRlIF9kb21TYW5pdGl6ZXI/OiBEb21TYW5pdGl6ZXIsIEBPcHRpb25hbCgpIGNvbmZpZz86IFNob3dkb3duQ29uZmlnKSB7XG4gICAgc3VwZXIoY29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGFuZ3VsYXIgbGlmZWN5Y2xlIG1ldGhvZCwgVXNlIG9uIGluaXQgdG8gY2hlY2sgaWYgaXQgYGNvbnRlbnRgIHR5cGUgYW5kIGxvYWQgdGhlIGVsZW1lbnQgYGNvbnRlbnRgIHRvIGB2YWx1ZWAuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuaW5uZXJIVE1MLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgIHRoaXMucmVuZGVyKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5pbm5lckhUTUwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIGFuZ3VsYXIgbGlmZWN5Y2xlIG1ldGhvZCwgVXNlIHRvIGNhbGwgdG8gcmVuZGVyIG1ldGhvZCBhZnRlciBjaGFuZ2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5nT25DaGFuZ2VzKCk6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGUgbWFya2Rvd24gdmFsdWUgb2Yge0BsaW5rIFNob3dkb3duQ29tcG9uZW50I3ZhbHVlfSB0byBodG1sIGFuZCBzZXQgdGhlIGh0bWwgcmVzdWx0IHRvIHRoZSBlbGVtZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIF9fRXhhbXBsZSA6X19cbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8dGV4dGFyZWEgI3RleHRhcmVhIChjaGFuZ2UpPVwic2hvd2Rvd24ucmVuZGVyKHRleHRhcmVhLnZhbHVlKVwiLz4jIFNvbWUgSGVhZGVyPC90ZXh0YXJlYT5cbiAgICogPHNob3dkb3duICNzaG93ZG93bj48L3Nob3dkb3duPlxuICAgKiBgYGBcbiAgICogQHBhcmFtIHZhbHVlIC0gQSBtYXJrZG93biB2YWx1ZSB0byByZW5kZXIgKGl0IHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYFNob3dkb3duQ29tcG9uZW50I3ZhbHVlYClcbiAgICovXG4gIHB1YmxpYyByZW5kZXIodmFsdWU/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCByZXN1bHQgPSB0aGlzLm1ha2VIdG1sKHRoaXMudmFsdWUpO1xuXG4gICAgICBpZiAodGhpcy5fc2FuaXRpemUpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fZG9tU2FuaXRpemVyLnNhbml0aXplKFNlY3VyaXR5Q29udGV4dC5IVE1MLCByZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuaW5uZXJIVE1MID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqIEBkZXByZWNhdGVkIGZyb20gdjUsIHVzZSB7QGxpbmsgU2hvd2Rvd25Db21wb25lbnQjc21hcnRJbmRlbnRhdGlvbkZpeH0gaW5zdGVhZC5cbiAgICovXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptZW1iZXItb3JkZXJpbmdcbiAgdHJpbUVhY2hMaW5lO1xuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqIEBkZXByZWNhdGVkIGZyb20gdjUsICB1c2Uge0BsaW5rIFNob3dkb3duQ29tcG9uZW50I3JlbmRlcn0gbWV0aG9kIGluc3RlYWQuXG4gICAqL1xuICBzZXRWYWx1ZT8odmFsdWU6IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICogQGRlcHJlY2F0ZWQgZnJvbSB2NSwgdXNlIHtAbGluayBTaG93ZG93bkNvbXBvbmVudCNyZW5kZXJ9IG1ldGhvZCBpbnN0ZWFkLlxuICAgKi9cbiAgY29tcGlsZT8oKTogdm9pZDtcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKiBAZGVwcmVjYXRlZCBmcm9tIHY1LCB1c2UgYGlubmVySFRNTGAgcHJvcGVydHkgb2YgdGhlIGVsZW1lbnQgaW5zdGVhZC5cbiAgICovXG4gIHRvSFRNTD8oKTogc3RyaW5nO1xuXG59XG5cbi8qKlxuICogQGlnbm9yZVxuICogQGRlcHJlY2F0ZWQgZnJvbSB2NSwgcmVuYW1lZCBgU2hvd2Rvd25EaXJlY3RpdmVgIHRvIHtAbGluayBTaG93ZG93bkNvbXBvbmVudH0uXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGxldCBTaG93ZG93bkRpcmVjdGl2ZTogdHlwZW9mIFNob3dkb3duQ29tcG9uZW50O1xuXG4vLyBEZWZpbmUgb3B0aW9ucyBwcm9wZXJ0aWVzIHNldHRlciBmb3IgYW5ndWxhciBkaXJlY3RpdmUgYW5kIGRpcmVjdCBhY2Nlc3NcbmZvciAobGV0IGtleSBvZiBPUFRJT05TX1BST1BFUlRJRVNfS0VZUykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hvd2Rvd25Db21wb25lbnQucHJvdG90eXBlLCBrZXksIHtcbiAgICBzZXQodmFsdWU6IGFueSk6IHZvaWQge1xuICAgICAgdGhpcy5zZXRPcHRpb24oa2V5LCBfdG9PcHRpb24odmFsdWUpKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbiJdfQ==